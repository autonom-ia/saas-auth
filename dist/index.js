const{Sequelize:Sequelize}=require("sequelize");const{initializeMockDatabase:initializeMockDatabase}=require("../data/mockDatabase.js");const{defineUser:defineUser}=require("../models/user.js");const{defineProduct:defineProduct}=require("../models/product.js");const{defineClient:defineClient}=require("../models/client.js");let sequelize;let models={};const initializeDatabase=async()=>{if(process.env.USE_DATABASE==="true"){if(!sequelize){console.log("Initializing database connection with:",{name:process.env.DB_NAME,user:process.env.DB_USER,host:process.env.DB_HOST,port:process.env.DB_PORT});sequelize=new Sequelize(process.env.DB_NAME,process.env.DB_USER,process.env.DB_PASSWORD,{host:process.env.DB_HOST,port:process.env.DB_PORT,dialect:"postgres",logging:console.log,dialectOptions:{ssl:{require:true,rejectUnauthorized:false}},pool:{max:2,min:0,acquire:3e4,idle:1e4}});try{await sequelize.authenticate();console.log("Database connection has been established successfully.");models.User=defineUser(sequelize);models.Product=defineProduct(sequelize);models.Client=defineClient(sequelize);await sequelize.sync();console.log("Database synchronized successfully.")}catch(error){console.error("Unable to connect to the database:",error);throw error}}return models}else{console.log("Using mock database");return initializeMockDatabase()}};module.exports={initializeDatabase:initializeDatabase};const bcrypt=require("bcryptjs");const mockedUsers=[{id:"550e8400-e29b-41d4-a716-446655440000",name:"Test User",email:"test@example.com",password:"$2a$10$o9iV8nR2LtUIOTzHvU79luijxwAYkhLiGy4oAcoLwPXtsbHbY9Ww6",access_type:"U",created_at:"2025-01-27T14:23:31.000Z",last_access:"2025-01-27T14:23:31.000Z"},{id:"8d43c7e9-2e9d-4abc-b57b-ebca03ccb1a4",name:"Admin",email:"admin@autonomia.site",password:"$2a$10$YNBvgTKNUzNkQYgFwjAXTOhSYxQxdXzQpBvzHcNyNzKbBL5dOHKDu",access_type:"A",created_at:"2025-01-27T14:23:31.000Z",last_access:"2025-01-27T14:23:31.000Z"}];module.exports={mockedUsers:mockedUsers};const{mockedUsers:mockedUsers,mockedProducts:mockedProducts,mockedClients:mockedClients}=require("./mockData.js");const bcrypt=require("bcryptjs");const{v4:uuidv4}=require("uuid");class MockUser{constructor(data){this.id=data.id;this.name=data.name;this.email=data.email;this.password=data.password;this.access_type=data.access_type;this.client_id=data.client_id;this.created_at=data.created_at;this.last_access=data.last_access}async checkPassword(password){return bcrypt.compareSync(password,this.password)}async update(data){Object.assign(this,data);if(data.password){this.password=bcrypt.hashSync(data.password,10)}return this}async destroy(){const index=mockedUsers.findIndex((user=>user.id===this.id));if(index!==-1){mockedUsers.splice(index,1)}}toJSON(){const{password:password,...data}=this;return data}}class MockProduct{constructor(data){this.id=data.id;this.name=data.name;this.description=data.description;this.agent_instructions=data.agent_instructions;this.created_at=data.created_at;this.updated_at=data.updated_at}async update(data){Object.assign(this,data);this.updated_at=(new Date).toISOString();return this}async destroy(){const index=mockedProducts.findIndex((product=>product.id===this.id));if(index!==-1){mockedProducts.splice(index,1)}}toJSON(){return{...this}}}class MockClient{constructor(data){this.id=data.id;this.name=data.name;this.email=data.email;this.phone=data.phone;this.created_at=data.created_at;this.updated_at=data.updated_at}async update(data){Object.assign(this,data);this.updated_at=(new Date).toISOString();return this}async destroy(){const index=mockedClients.findIndex((client=>client.id===this.id));if(index!==-1){mockedClients.splice(index,1)}}toJSON(){return{...this}}}class MockUserModel{static async findOne({where:where}){const user=mockedUsers.find((u=>Object.entries(where).every((([key,value])=>{if(key==="email"&&value[Symbol.for("Op.iLike")]){const pattern=value[Symbol.for("Op.iLike")].replace(/%/g,".*");return new RegExp(pattern,"i").test(u.email)}return u[key]===value}))));return user?new MockUser(user):null}static async findByPk(id){const user=mockedUsers.find((u=>u.id===id));return user?new MockUser(user):null}static async findAll(options={}){let users=[...mockedUsers];if(options.where){users=users.filter((u=>Object.entries(options.where).every((([key,value])=>u[key]===value))))}return users.map((u=>new MockUser(u)))}static async create(data){const user={id:uuidv4(),...data,created_at:(new Date).toISOString(),last_access:(new Date).toISOString()};mockedUsers.push(user);return new MockUser(user)}}class MockProductModel{static async findOne({where:where}){const product=mockedProducts.find((p=>Object.entries(where).every((([key,value])=>p[key]===value))));return product?new MockProduct(product):null}static async findByPk(id){const product=mockedProducts.find((p=>p.id===id));return product?new MockProduct(product):null}static async findAll(options={}){let products=[...mockedProducts];if(options.where){products=products.filter((p=>Object.entries(options.where).every((([key,value])=>p[key]===value))))}return products.map((p=>new MockProduct(p)))}static async create(data){const product={id:uuidv4(),...data,created_at:(new Date).toISOString(),updated_at:(new Date).toISOString()};mockedProducts.push(product);return new MockProduct(product)}static async findAndCountAll(options={}){let products=[...mockedProducts];if(options.where){products=products.filter((p=>Object.entries(options.where).every((([key,value])=>p[key]===value))))}if(options.offset){products=products.slice(options.offset)}if(options.limit){products=products.slice(0,options.limit)}return{count:mockedProducts.length,rows:products.map((p=>new MockProduct(p)))}}}class MockClientModel{static async findOne({where:where}){const client=mockedClients.find((c=>Object.entries(where).every((([key,value])=>c[key]===value))));return client?new MockClient(client):null}static async findByPk(id){const client=mockedClients.find((c=>c.id===id));return client?new MockClient(client):null}static async findAll(options={}){let clients=[...mockedClients];if(options.where){clients=clients.filter((c=>Object.entries(options.where).every((([key,value])=>c[key]===value))))}return clients.map((c=>new MockClient(c)))}static async create(data){const client={id:uuidv4(),...data,created_at:(new Date).toISOString(),updated_at:(new Date).toISOString()};mockedClients.push(client);return new MockClient(client)}static async findAndCountAll(options={}){let clients=[...mockedClients];if(options.where){clients=clients.filter((c=>Object.entries(options.where).every((([key,value])=>c[key]===value))))}if(options.offset){clients=clients.slice(options.offset)}if(options.limit){clients=clients.slice(0,options.limit)}return{count:mockedClients.length,rows:clients.map((c=>new MockClient(c)))}}}const initializeMockDatabase=()=>({User:MockUserModel,Product:MockProductModel,Client:MockClientModel});module.exports={initializeMockDatabase:initializeMockDatabase};const mockUsers=[{id:"8d43c7e9-2e9d-4abc-b57b-ebca03ccb1a4",name:"Admin",email:"admin@autonomia.site",password:"$2a$10$YourHashedPasswordHere",access_type:"A",created_at:"2025-01-27T14:23:31.000Z",last_access:"2025-01-27T14:23:31.000Z"},{id:"9f43c7e9-2e9d-4abc-b57b-ebca03ccb1a5",name:"Test User",email:"test@example.com",password:"$2a$10$YourHashedPasswordHere",access_type:"U",created_at:"2025-01-27T14:23:31.000Z",last_access:"2025-01-27T14:23:31.000Z"}];module.exports={mockUsers:mockUsers};const{authService:authService}=require("../services/authService");module.exports.login=async event=>{try{const{email:email,password:password}=JSON.parse(event.body);if(!email||!password){return{statusCode:400,headers:{"Content-Type":"application/json","Access-Control-Allow-Origin":"*"},body:JSON.stringify({error:"Email and password are required"})}}const result=await authService.login(email,password);return{statusCode:200,headers:{"Content-Type":"application/json","Access-Control-Allow-Origin":"*"},body:JSON.stringify(result)}}catch(error){return{statusCode:error.message==="Invalid credentials"?401:500,headers:{"Content-Type":"application/json","Access-Control-Allow-Origin":"*"},body:JSON.stringify({error:error.message})}}};const bcrypt=require("bcryptjs");const jwt=require("jsonwebtoken");const{mockedUsers:mockedUsers}=require("../data/mockData");const{Op:Op}=require("sequelize");class AuthService{constructor(){this.useDatabase=process.env.USE_DATABASE==="true";this.User=null}async setUser(User){this.User=User}async findUserByEmail(email){console.log("Finding user by email:",email);console.log("Using database:",this.useDatabase);if(this.useDatabase){if(!this.User){throw new Error("User model not initialized")}return await this.User.findOne({where:{email:email}})}else{console.log("Using mocked data");return mockedUsers.find((user=>user.email===email))}}async updateLastAccess(user){if(this.useDatabase){if(!this.User){throw new Error("User model not initialized")}user.last_access=new Date;await user.save()}}generateToken(user){return jwt.sign({id:user.id,email:user.email,name:user.name,access_type:user.access_type},process.env.JWT_SECRET||"test-secret-key",{expiresIn:"1d"})}formatUserResponse(user){return{id:user.id,name:user.name,email:user.email,access_type:user.access_type,created_at:user.created_at,last_access:user.last_access}}async login(email,password){const user=await this.findUserByEmail(email);if(!user){throw new Error("Invalid credentials")}const isValidPassword=await bcrypt.compare(password,user.password);if(!isValidPassword){throw new Error("Invalid credentials")}await this.updateLastAccess(user);return{token:this.generateToken(user),user:this.formatUserResponse(user)}}}const authService=new AuthService;module.exports={authService:authService};